!function (e) { if ("object" == typeof exports && "undefined" != typeof module) module.exports = e(); else if ("function" == typeof define && define.amd) define([], e); else { var t; "undefined" != typeof window ? t = window : "undefined" != typeof global ? t = global : "undefined" != typeof self && (t = self), t.webStreamsPolyfill = e() } }(function () {
    return function e(t, r, n) { function o(i, s) { if (!r[i]) { if (!t[i]) { var l = "function" == typeof require && require; if (!s && l) return l(i, !0); if (a) return a(i, !0); var u = new Error("Cannot find module '" + i + "'"); throw u.code = "MODULE_NOT_FOUND", u } var d = r[i] = { exports: {} }; t[i][0].call(d.exports, function (e) { var r = t[i][1][e]; return o(r ? r : e) }, d, d.exports, e, t, r, n) } return r[i].exports } for (var a = "function" == typeof require && require, i = 0; i < n.length; i++) o(n[i]); return o }({
        1: [function (e, t, r) { function n(e, t) { return y.isUndefined(t) ? "" + t : !y.isNumber(t) || !isNaN(t) && isFinite(t) ? y.isFunction(t) || y.isRegExp(t) ? t.toString() : t : t.toString() } function o(e, t) { return y.isString(e) ? e.length < t ? e : e.slice(0, t) : e } function a(e) { return o(JSON.stringify(e.actual, n), 128) + " " + e.operator + " " + o(JSON.stringify(e.expected, n), 128) } function i(e, t, r, n, o) { throw new _.AssertionError({ message: r, actual: e, expected: t, operator: n, stackStartFunction: o }) } function s(e, t) { e || i(e, !0, t, "==", _.ok) } function l(e, t) { if (e === t) return !0; if (y.isBuffer(e) && y.isBuffer(t)) { if (e.length != t.length) return !1; for (var r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1; return !0 } return y.isDate(e) && y.isDate(t) ? e.getTime() === t.getTime() : y.isRegExp(e) && y.isRegExp(t) ? e.source === t.source && e.global === t.global && e.multiline === t.multiline && e.lastIndex === t.lastIndex && e.ignoreCase === t.ignoreCase : y.isObject(e) || y.isObject(t) ? d(e, t) : e == t } function u(e) { return "[object Arguments]" == Object.prototype.toString.call(e) } function d(e, t) { if (y.isNullOrUndefined(e) || y.isNullOrUndefined(t)) return !1; if (e.prototype !== t.prototype) return !1; if (u(e)) return u(t) ? (e = h.call(e), t = h.call(t), l(e, t)) : !1; try { var r, n, o = p(e), a = p(t) } catch (i) { return !1 } if (o.length != a.length) return !1; for (o.sort(), a.sort(), n = o.length - 1; n >= 0; n--) if (o[n] != a[n]) return !1; for (n = o.length - 1; n >= 0; n--) if (r = o[n], !l(e[r], t[r])) return !1; return !0 } function c(e, t) { return e && t ? "[object RegExp]" == Object.prototype.toString.call(t) ? t.test(e) : e instanceof t ? !0 : t.call({}, e) === !0 : !1 } function f(e, t, r, n) { var o; y.isString(r) && (n = r, r = null); try { t() } catch (a) { o = a } if (n = (r && r.name ? " (" + r.name + ")." : ".") + (n ? " " + n : "."), e && !o && i(o, r, "Missing expected exception" + n), !e && c(o, r) && i(o, r, "Got unwanted exception" + n), e && o && r && !c(o, r) || !e && o) throw o } var y = e("util/"), h = Array.prototype.slice, b = Object.prototype.hasOwnProperty, _ = t.exports = s; _.AssertionError = function (e) { this.name = "AssertionError", this.actual = e.actual, this.expected = e.expected, this.operator = e.operator, e.message ? (this.message = e.message, this.generatedMessage = !1) : (this.message = a(this), this.generatedMessage = !0); var t = e.stackStartFunction || i; if (Error.captureStackTrace) Error.captureStackTrace(this, t); else { var r = new Error; if (r.stack) { var n = r.stack, o = t.name, s = n.indexOf("\n" + o); if (s >= 0) { var l = n.indexOf("\n", s + 1); n = n.substring(l + 1) } this.stack = n } } }, y.inherits(_.AssertionError, Error), _.fail = i, _.ok = s, _.equal = function (e, t, r) { e != t && i(e, t, r, "==", _.equal) }, _.notEqual = function (e, t, r) { e == t && i(e, t, r, "!=", _.notEqual) }, _.deepEqual = function (e, t, r) { l(e, t) || i(e, t, r, "deepEqual", _.deepEqual) }, _.notDeepEqual = function (e, t, r) { l(e, t) && i(e, t, r, "notDeepEqual", _.notDeepEqual) }, _.strictEqual = function (e, t, r) { e !== t && i(e, t, r, "===", _.strictEqual) }, _.notStrictEqual = function (e, t, r) { e === t && i(e, t, r, "!==", _.notStrictEqual) }, _["throws"] = function (e, t, r) { f.apply(this, [!0].concat(h.call(arguments))) }, _.doesNotThrow = function (e, t) { f.apply(this, [!1].concat(h.call(arguments))) }, _.ifError = function (e) { if (e) throw e }; var p = Object.keys || function (e) { var t = []; for (var r in e) b.call(e, r) && t.push(r); return t } }, { "util/": 5 }], 2: [function (e, t, r) { "function" == typeof Object.create ? t.exports = function (e, t) { e.super_ = t, e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }) } : t.exports = function (e, t) { e.super_ = t; var r = function () { }; r.prototype = t.prototype, e.prototype = new r, e.prototype.constructor = e } }, {}], 3: [function (e, t, r) { function n() { } var o = t.exports = {}; o.nextTick = function () { var e = "undefined" != typeof window && window.setImmediate, t = "undefined" != typeof window && window.MutationObserver, r = "undefined" != typeof window && window.postMessage && window.addEventListener; if (e) return function (e) { return window.setImmediate(e) }; var n = []; if (t) { var o = document.createElement("div"), a = new MutationObserver(function () { var e = n.slice(); n.length = 0, e.forEach(function (e) { e() }) }); return a.observe(o, { attributes: !0 }), function (e) { n.length || o.setAttribute("yes", "no"), n.push(e) } } return r ? (window.addEventListener("message", function (e) { var t = e.source; if ((t === window || null === t) && "process-tick" === e.data && (e.stopPropagation(), n.length > 0)) { var r = n.shift(); r() } }, !0), function (e) { n.push(e), window.postMessage("process-tick", "*") }) : function (e) { setTimeout(e, 0) } }(), o.title = "browser", o.browser = !0, o.env = {}, o.argv = [], o.on = n, o.addListener = n, o.once = n, o.off = n, o.removeListener = n, o.removeAllListeners = n, o.emit = n, o.binding = function (e) { throw new Error("process.binding is not supported") }, o.cwd = function () { return "/" }, o.chdir = function (e) { throw new Error("process.chdir is not supported") } }, {}], 4: [function (e, t, r) { t.exports = function (e) { return e && "object" == typeof e && "function" == typeof e.copy && "function" == typeof e.fill && "function" == typeof e.readUInt8 } }, {}], 5: [function (e, t, r) { (function (t, n) { function o(e, t) { var n = { seen: [], stylize: i }; return arguments.length >= 3 && (n.depth = arguments[2]), arguments.length >= 4 && (n.colors = arguments[3]), b(t) ? n.showHidden = t : t && r._extend(n, t), g(n.showHidden) && (n.showHidden = !1), g(n.depth) && (n.depth = 2), g(n.colors) && (n.colors = !1), g(n.customInspect) && (n.customInspect = !0), n.colors && (n.stylize = a), l(n, e, n.depth) } function a(e, t) { var r = o.styles[t]; return r ? "[" + o.colors[r][0] + "m" + e + "[" + o.colors[r][1] + "m" : e } function i(e, t) { return e } function s(e) { var t = {}; return e.forEach(function (e, r) { t[e] = !0 }), t } function l(e, t, n) { if (e.customInspect && t && E(t.inspect) && t.inspect !== r.inspect && (!t.constructor || t.constructor.prototype !== t)) { var o = t.inspect(n, e); return v(o) || (o = l(e, o, n)), o } var a = u(e, t); if (a) return a; var i = Object.keys(t), b = s(i); if (e.showHidden && (i = Object.getOwnPropertyNames(t)), P(t) && (i.indexOf("message") >= 0 || i.indexOf("description") >= 0)) return d(t); if (0 === i.length) { if (E(t)) { var _ = t.name ? ": " + t.name : ""; return e.stylize("[Function" + _ + "]", "special") } if (R(t)) return e.stylize(RegExp.prototype.toString.call(t), "regexp"); if (B(t)) return e.stylize(Date.prototype.toString.call(t), "date"); if (P(t)) return d(t) } var p = "", m = !1, w = ["{", "}"]; if (h(t) && (m = !0, w = ["[", "]"]), E(t)) { var g = t.name ? ": " + t.name : ""; p = " [Function" + g + "]" } if (R(t) && (p = " " + RegExp.prototype.toString.call(t)), B(t) && (p = " " + Date.prototype.toUTCString.call(t)), P(t) && (p = " " + d(t)), 0 === i.length && (!m || 0 == t.length)) return w[0] + p + w[1]; if (0 > n) return R(t) ? e.stylize(RegExp.prototype.toString.call(t), "regexp") : e.stylize("[Object]", "special"); e.seen.push(t); var S; return S = m ? c(e, t, n, b, i) : i.map(function (r) { return f(e, t, n, b, r, m) }), e.seen.pop(), y(S, p, w) } function u(e, t) { if (g(t)) return e.stylize("undefined", "undefined"); if (v(t)) { var r = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'"; return e.stylize(r, "string") } return m(t) ? e.stylize("" + t, "number") : b(t) ? e.stylize("" + t, "boolean") : _(t) ? e.stylize("null", "null") : void 0 } function d(e) { return "[" + Error.prototype.toString.call(e) + "]" } function c(e, t, r, n, o) { for (var a = [], i = 0, s = t.length; s > i; ++i) k(t, String(i)) ? a.push(f(e, t, r, n, String(i), !0)) : a.push(""); return o.forEach(function (o) { o.match(/^\d+$/) || a.push(f(e, t, r, n, o, !0)) }), a } function f(e, t, r, n, o, a) { var i, s, u; if (u = Object.getOwnPropertyDescriptor(t, o) || { value: t[o] }, u.get ? s = u.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : u.set && (s = e.stylize("[Setter]", "special")), k(n, o) || (i = "[" + o + "]"), s || (e.seen.indexOf(u.value) < 0 ? (s = _(r) ? l(e, u.value, null) : l(e, u.value, r - 1), s.indexOf("\n") > -1 && (s = a ? s.split("\n").map(function (e) { return "  " + e }).join("\n").substr(2) : "\n" + s.split("\n").map(function (e) { return "   " + e }).join("\n"))) : s = e.stylize("[Circular]", "special")), g(i)) { if (a && o.match(/^\d+$/)) return s; i = JSON.stringify("" + o), i.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (i = i.substr(1, i.length - 2), i = e.stylize(i, "name")) : (i = i.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), i = e.stylize(i, "string")) } return i + ": " + s } function y(e, t, r) { var n = 0, o = e.reduce(function (e, t) { return n++, t.indexOf("\n") >= 0 && n++, e + t.replace(/\u001b\[\d\d?m/g, "").length + 1 }, 0); return o > 60 ? r[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + r[1] : r[0] + t + " " + e.join(", ") + " " + r[1] } function h(e) { return Array.isArray(e) } function b(e) { return "boolean" == typeof e } function _(e) { return null === e } function p(e) { return null == e } function m(e) { return "number" == typeof e } function v(e) { return "string" == typeof e } function w(e) { return "symbol" == typeof e } function g(e) { return void 0 === e } function R(e) { return S(e) && "[object RegExp]" === T(e) } function S(e) { return "object" == typeof e && null !== e } function B(e) { return S(e) && "[object Date]" === T(e) } function P(e) { return S(e) && ("[object Error]" === T(e) || e instanceof Error) } function E(e) { return "function" == typeof e } function q(e) { return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || "undefined" == typeof e } function T(e) { return Object.prototype.toString.call(e) } function O(e) { return 10 > e ? "0" + e.toString(10) : e.toString(10) } function j() { var e = new Date, t = [O(e.getHours()), O(e.getMinutes()), O(e.getSeconds())].join(":"); return [e.getDate(), A[e.getMonth()], t].join(" ") } function k(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } var C = /%[sdj%]/g; r.format = function (e) { if (!v(e)) { for (var t = [], r = 0; r < arguments.length; r++) t.push(o(arguments[r])); return t.join(" ") } for (var r = 1, n = arguments, a = n.length, i = String(e).replace(C, function (e) { if ("%%" === e) return "%"; if (r >= a) return e; switch (e) { case "%s": return String(n[r++]); case "%d": return Number(n[r++]); case "%j": try { return JSON.stringify(n[r++]) } catch (t) { return "[Circular]" } default: return e } }), s = n[r]; a > r; s = n[++r]) i += _(s) || !S(s) ? " " + s : " " + o(s); return i }, r.deprecate = function (e, o) { function a() { if (!i) { if (t.throwDeprecation) throw new Error(o); t.traceDeprecation ? console.trace(o) : console.error(o), i = !0 } return e.apply(this, arguments) } if (g(n.process)) return function () { return r.deprecate(e, o).apply(this, arguments) }; if (t.noDeprecation === !0) return e; var i = !1; return a }; var I, z = {}; r.debuglog = function (e) { if (g(I) && (I = t.env.NODE_DEBUG || ""), e = e.toUpperCase(), !z[e]) if (new RegExp("\\b" + e + "\\b", "i").test(I)) { var n = t.pid; z[e] = function () { var t = r.format.apply(r, arguments); console.error("%s %d: %s", e, n, t) } } else z[e] = function () { }; return z[e] }, r.inspect = o, o.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, o.styles = { special: "cyan", number: "yellow", "boolean": "yellow", undefined: "grey", "null": "bold", string: "green", date: "magenta", regexp: "red" }, r.isArray = h, r.isBoolean = b, r.isNull = _, r.isNullOrUndefined = p, r.isNumber = m, r.isString = v, r.isSymbol = w, r.isUndefined = g, r.isRegExp = R, r.isObject = S, r.isDate = B, r.isError = P, r.isFunction = E, r.isPrimitive = q, r.isBuffer = e("./support/isBuffer"); var A = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; r.log = function () { console.log("%s - %s", j(), r.format.apply(r, arguments)) }, r.inherits = e("inherits"), r._extend = function (e, t) { if (!t || !S(t)) return e; for (var r = Object.keys(t), n = r.length; n--;) e[r[n]] = t[r[n]]; return e } }).call(this, e("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, { "./support/isBuffer": 4, _process: 3, inherits: 2 }], 6: [function (e, t, r) {
            (function (t) {
                "use strict"; function n(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function o(e) { return "object" === ("undefined" == typeof e ? "undefined" : at(e)) && null !== e || "function" == typeof e } function a(e, t, r) { it(o(e)), Object.defineProperty(e, t, { value: r, writable: !0, enumerable: !0, configurable: !0 }) } function i(e) { return e.slice() } function s(e, t, r, n, o) { new Uint8Array(e).set(new Uint8Array(r, n, o), t) } function l(e, t) { it("boolean" == typeof t); var r = {}; return Object.defineProperty(r, "value", { value: e, enumerable: !0, writable: !0, configurable: !0 }), Object.defineProperty(r, "done", { value: t, enumerable: !0, writable: !0, configurable: !0 }), r } function u(e) { return Number.isNaN(e) ? !1 : e === +(1 / 0) ? !1 : !(0 > e) } function d(e, t, r) { var n = e[t]; return void 0 !== n ? n.apply(e, r) : void 0 } function c(e, t, r) { var n = void 0; try { n = e[t] } catch (o) { return Promise.reject(o) } if (void 0 === n) return Promise.resolve(void 0); try { return Promise.resolve(n.apply(e, r)) } catch (a) { return Promise.reject(a) } } function f(e, t, r, n, o) { var a = void 0; try { a = e[t] } catch (i) { return Promise.reject(i) } if (void 0 === a) return c(e, n, o); try { return Promise.resolve(a.apply(e, r)) } catch (s) { return Promise.reject(s) } } function y(e) { return e } function h(e) { if (e = Number(e), Number.isNaN(e)) throw new TypeError("highWaterMark property of a queuing strategy must be convertible to a non-NaN number"); if (0 > e) throw new RangeError("highWaterMark property of a queuing strategy must be nonnegative"); return e } function b(e, t) { if (void 0 !== e && "function" != typeof e) throw new TypeError("size property of a queuing strategy must be a function"); return t = h(t), { size: e, highWaterMark: t } } function _(e) { e && e.constructor === st.AssertionError && setTimeout(function () { throw e }, 0) } function p(e) { lt(e.length > 0, "Spec-level failure: should never dequeue from an empty queue."); var t = e.shift(); return t.value } function m(e, t, r) { if (r = Number(r), !u(r)) throw new RangeError("Size must be a finite, non-NaN, non-negative number."); e.push({ value: t, size: r }) } function v(e) { var t = 0; return e.forEach(function (e) { lt("number" == typeof e.size && !Number.isNaN(e.size) && e.size !== +(1 / 0) && e.size !== -(1 / 0), "Spec-level failure: should never find an invalid size in the queue."), t += e.size }), t } function w(e) { lt(e.length > 0, "Spec-level failure: should never peek at an empty queue."); var t = e[0]; return t.value } function g(e) { return new ht(e) } function R(e) { return new yt(e) } function S(e) { return o(e) ? !!Object.prototype.hasOwnProperty.call(e, "_readableStreamController") : !1 } function B(e) { return ut(S(e) === !0, "IsReadableStreamLocked should only be used on known readable streams"), void 0 !== e._reader } function P(e, t) { ut(S(e) === !0), ut("boolean" == typeof t); var r = R(e), n = { closedOrErrored: !1, canceled1: !1, canceled2: !1, reason1: void 0, reason2: void 0 }; n.promise = new Promise(function (e) { return n._resolve = e }); var o = E(); o._reader = r, o._teeState = n, o._shouldClone = t; var i = q(); i._stream = e, i._teeState = n; var s = T(); s._stream = e, s._teeState = n; var l = Object.create(Object.prototype); a(l, "pull", o), a(l, "cancel", i); var u = new ft(l), d = Object.create(Object.prototype); a(d, "pull", o), a(d, "cancel", s); var c = new ft(d); return o._branch1 = u._readableStreamController, o._branch2 = c._readableStreamController, r._closedPromise["catch"](function (e) { n.closedOrErrored !== !0 && (K(o._branch1, e), K(o._branch2, e), n.closedOrErrored = !0) }), [u, c] } function E() { var e = function t() { var e = t._reader, r = t._branch1, n = t._branch2, a = t._teeState; return t._shouldClone, H(e).then(function (e) { ut(o(e)); var t = e.value, i = e.done; if (ut("boolean" == typeof i), i === !0 && a.closedOrErrored === !1 && (a.canceled1 === !1 && G(r), a.canceled2 === !1 && G(n), a.closedOrErrored = !0), a.closedOrErrored !== !0) { if (a.canceled1 === !1) { var s = t; Z(r, s) } if (a.canceled2 === !1) { var l = t; Z(n, l) } } }) }; return e } function q() { var e = function t(e) { var r = t._stream, n = t._teeState; if (n.canceled1 = !0, n.reason1 = e, n.canceled2 === !0) { var o = i([n.reason1, n.reason2]), a = k(r, o); n._resolve(a) } return n.promise }; return e } function T() { var e = function t(e) { var r = t._stream, n = t._teeState; if (n.canceled2 = !0, n.reason2 = e, n.canceled1 === !0) { var o = i([n.reason1, n.reason2]), a = k(r, o); n._resolve(a) } return n.promise }; return e } function O(e) { ut(D(e._reader) === !0); var t = new Promise(function (t, r) { var n = { _resolve: t, _reject: r }; e._reader._readIntoRequests.push(n) }); return t } function j(e) { ut(N(e._reader) === !0); var t = new Promise(function (t, r) { var n = { _resolve: t, _reject: r }; e._reader._readRequests.push(n) }); return t } function k(e, t) { if (ut(void 0 !== e), e._disturbed = !0, "closed" === e._state) return Promise.resolve(void 0); if ("errored" === e._state) return Promise.reject(e._storedError); C(e); var r = e._readableStreamController[dt](t); return r.then(function () { }) } function C(e) { ut("readable" === e._state), e._state = "closed"; var t = e._reader; if (void 0 !== t) { if (N(t) === !0) { var r = !0, n = !1, o = void 0; try { for (var a, i = t._readRequests[Symbol.iterator]() ; !(r = (a = i.next()).done) ; r = !0) { var s = a.value._resolve; s(l(void 0, !0)) } } catch (u) { n = !0, o = u } finally { try { !r && i["return"] && i["return"]() } finally { if (n) throw o } } t._readRequests = [] } t._closedPromise_resolve(void 0), t._closedPromise_resolve = void 0, t._closedPromise_reject = void 0 } } function I(e, t) { ut(S(e) === !0, "stream must be ReadableStream"), ut("readable" === e._state, "state must be readable"), e._state = "errored", e._storedError = t; var r = e._reader; if (void 0 !== r) { if (N(r) === !0) { var n = !0, o = !1, a = void 0; try { for (var i, s = r._readRequests[Symbol.iterator]() ; !(n = (i = s.next()).done) ; n = !0) { var l = i.value; l._reject(t) } } catch (u) { o = !0, a = u } finally { try { !n && s["return"] && s["return"]() } finally { if (o) throw a } } r._readRequests = [] } else { ut(D(r), "reader must be ReadableStreamBYOBReader"); var d = !0, c = !1, f = void 0; try { for (var y, h = r._readIntoRequests[Symbol.iterator]() ; !(d = (y = h.next()).done) ; d = !0) { var b = y.value; b._reject(t) } } catch (u) { c = !0, f = u } finally { try { !d && h["return"] && h["return"]() } finally { if (c) throw f } } r._readIntoRequests = [] } r._closedPromise_reject(t), r._closedPromise_resolve = void 0, r._closedPromise_reject = void 0 } } function z(e, t, r) { var n = e._reader; ut(n._readIntoRequests.length > 0); var o = n._readIntoRequests.shift(); o._resolve(l(t, r)) } function A(e, t, r) { var n = e._reader; ut(n._readRequests.length > 0); var o = n._readRequests.shift(); o._resolve(l(t, r)) } function L(e) { return e._reader._readIntoRequests.length } function F(e) { return e._reader._readRequests.length } function x(e) { var t = e._reader; return void 0 === t ? !1 : D(t) !== !1 } function Y(e) { var t = e._reader; return void 0 === t ? !1 : N(t) !== !1 } function D(e) { return o(e) ? !!Object.prototype.hasOwnProperty.call(e, "_readIntoRequests") : !1 } function N(e) { return o(e) ? !!Object.prototype.hasOwnProperty.call(e, "_readRequests") : !1 } function W(e, t) { e._ownerReadableStream = t, t._reader = e, "readable" === t._state ? e._closedPromise = new Promise(function (t, r) { e._closedPromise_resolve = t, e._closedPromise_reject = r }) : "closed" === t._state ? (e._closedPromise = Promise.resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0) : (ut("errored" === t._state, "state must be errored"), e._closedPromise = Promise.reject(t._storedError), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0) } function M(e, t) { return k(e._ownerReadableStream, t) } function Q(e) { ut(void 0 !== e._ownerReadableStream._reader), ut(void 0 !== e._ownerReadableStream), "readable" === e._ownerReadableStream._state ? e._closedPromise_reject(new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : e._closedPromise = Promise.reject(new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), e._ownerReadableStream._reader = void 0, e._ownerReadableStream = void 0 } function U(e, t) { var r = e._ownerReadableStream; return ut(void 0 !== r), r._disturbed = !0, "errored" === r._state ? Promise.reject(r._storedError) : ce(r._readableStreamController, t) } function H(e) { var t = e._ownerReadableStream; return ut(void 0 !== t), t._disturbed = !0, "closed" === t._state ? Promise.resolve(l(void 0, !0)) : "errored" === t._state ? Promise.reject(t._storedError) : (ut("readable" === t._state), t._readableStreamController[ct]()) } function J(e) { return o(e) ? !!Object.prototype.hasOwnProperty.call(e, "_underlyingSource") : !1 } function V(e) { var t = $(e); if (t !== !1) { if (e._pulling === !0) return void (e._pullAgain = !0); e._pulling = !0; var r = e._controlledReadableStream, n = c(e._underlyingSource, "pull", [e]); n.then(function () { return e._pulling = !1, e._pullAgain === !0 ? (e._pullAgain = !1, V(e)) : void 0 }, function (t) { return "readable" === r._state ? K(e, t) : void 0 })["catch"](_) } } function $(e) { var t = e._controlledReadableStream; if ("closed" === t._state || "errored" === t._state) return !1; if (e._closeRequested === !0) return !1; if (e._started === !1) return !1; if (B(t) === !0 && F(t) > 0) return !0; var r = X(e); return r > 0 } function G(e) { var t = e._controlledReadableStream; ut(e._closeRequested === !1), ut("readable" === t._state), e._closeRequested = !0, 0 === e._queue.length && C(t) } function Z(e, t) { var r = e._controlledReadableStream; if (ut(e._closeRequested === !1), ut("readable" === r._state), B(r) === !0 && F(r) > 0) A(r, t, !1); else { var n = 1; if (void 0 !== e._strategySize) try { n = e._strategySize(t) } catch (o) { throw "readable" === r._state && K(e, o), o } try { m(e._queue, t, n) } catch (a) { throw "readable" === r._state && K(e, a), a } } V(e) } function K(e, t) { var r = e._controlledReadableStream; ut("readable" === r._state), e._queue = [], I(r, t) } function X(e) { var t = v(e._queue); return e._strategyHWM - t } function ee(e) { return o(e) ? !!Object.prototype.hasOwnProperty.call(e, "_underlyingByteSource") : !1 } function te(e) { return o(e) ? !!Object.prototype.hasOwnProperty.call(e, "_associatedReadableStreamBYOBController") : !1 } function re(e) { var t = _e(e); if (t !== !1) { if (e._pulling === !0) return void (e._pullAgain = !0); e._pullAgain = !1, e._pulling = !0; var r = c(e._underlyingByteSource, "pull", [e]); r.then(function () { e._pulling = !1, e._pullAgain === !0 && (e._pullAgain = !1, re(e)) }, function (t) { "readable" === e._controlledReadableStream._state && ve(e, t) })["catch"](_) } } function ne(e) { void 0 !== e._byobRequest && (e._byobRequest._invalidate(), e._byobRequest = void 0), e._pendingPullIntos = [] } function oe(e, t) { ut("errored" !== e._state, "state must not be errored"); var r = !1; "closed" === e._state && (ut(0 === t.bytesFilled), r = !0); var n = ae(t); "default" === t.readerType ? A(e, n, r) : (ut("byob" === t.readerType), z(e, n, r)) } function ae(e) { var t = e.bytesFilled, r = e.elementSize; return ut(t <= e.byteLength), ut(t % r === 0), new e.ctor(e.buffer, e.byteOffset, t / r) } function ie(e, t, r, n) { e._queue.push({ buffer: t, byteOffset: r, byteLength: n }), e._totalQueuedBytes += n } function se(e, t) { var r = t.elementSize, n = t.bytesFilled - t.bytesFilled % r, o = Math.min(e._totalQueuedBytes, t.byteLength - t.bytesFilled), a = t.bytesFilled + o, i = a - a % r, l = o, u = !1; i > n && (l = i - t.bytesFilled, u = !0); for (var d = e._queue; l > 0;) { var c = d[0], f = Math.min(l, c.byteLength), y = t.byteOffset + t.bytesFilled; s(t.buffer, y, c.buffer, c.byteOffset, f), c.byteLength === f ? d.shift() : (c.byteOffset += f, c.byteLength -= f), e._totalQueuedBytes -= f, le(e, f, t), l -= f } return u === !1 && (ut(0 === e._totalQueuedBytes, "queue must be empty"), ut(t.bytesFilled > 0), ut(t.bytesFilled < t.elementSize)), u } function le(e, t, r) { ut(0 === e._pendingPullIntos.length || e._pendingPullIntos[0] === r), void 0 !== e._byobRequest && (e._byobRequest._invalidate(), e._byobRequest = void 0), r.bytesFilled += t } function ue(e) { ut("readable" === e._controlledReadableStream._state), 0 === e._totalQueuedBytes && e._closeRequested === !0 ? C(e._controlledReadableStream) : re(e) } function de(e) { for (ut(e._closeRequested === !1) ; e._pendingPullIntos.length > 0;) { if (0 === e._totalQueuedBytes) return; var t = e._pendingPullIntos[0]; se(e, t) === !0 && (be(e), oe(e._controlledReadableStream, t)) } } function ce(e, t) { var r = e._controlledReadableStream, n = 1; t.constructor !== DataView && (n = t.constructor.BYTES_PER_ELEMENT); var o = t.constructor, a = { buffer: t.buffer, byteOffset: t.byteOffset, byteLength: t.byteLength, bytesFilled: 0, elementSize: n, ctor: o, readerType: "byob" }; if (e._pendingPullIntos.length > 0) return a.buffer = y(a.buffer), e._pendingPullIntos.push(a), O(r); if ("closed" === r._state) { var i = new t.constructor(t.buffer, t.byteOffset, 0); return Promise.resolve(l(i, !0)) } if (e._totalQueuedBytes > 0) { if (se(e, a) === !0) { var s = ae(a); return ue(e), Promise.resolve(l(s, !1)) } if (e._closeRequested === !0) { var u = new TypeError("Insufficient bytes to fill elements in the given buffer"); return ve(e, u), Promise.reject(u) } } a.buffer = y(a.buffer), e._pendingPullIntos.push(a); var d = O(r); return re(e), d } function fe(e, t) { t.buffer = y(t.buffer), ut(0 === t.bytesFilled, "bytesFilled must be 0"); for (var r = e._controlledReadableStream; L(r) > 0;) { var n = be(e); oe(r, n) } } function ye(e, t, r) { if (r.bytesFilled + t > r.byteLength) throw new RangeError("bytesWritten out of range"); if (le(e, t, r), !(r.bytesFilled < r.elementSize)) { be(e); var n = r.bytesFilled % r.elementSize; if (n > 0) { var o = r.byteOffset + r.bytesFilled, a = r.buffer.slice(o - n, o); ie(e, a, 0, a.byteLength) } r.buffer = y(r.buffer), r.bytesFilled -= n, oe(e._controlledReadableStream, r), de(e) } } function he(e, t) { var r = e._pendingPullIntos[0], n = e._controlledReadableStream; if ("closed" === n._state) { if (0 !== t) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream"); fe(e, r) } else ut("readable" === n._state), ye(e, t, r) } function be(e) { var t = e._pendingPullIntos.shift(); return void 0 !== e._byobRequest && (e._byobRequest._invalidate(), e._byobRequest = void 0), t } function _e(e) { var t = e._controlledReadableStream; if ("readable" !== t._state) return !1; if (e._closeRequested === !0) return !1; if (e._started === !1) return !1; if (Y(t) && F(t) > 0) return !0; if (x(t) && L(t) > 0) return !0; var r = we(e); return r > 0 } function pe(e) { var t = e._controlledReadableStream; if (ut(e._closeRequested === !1), ut("readable" === t._state), e._totalQueuedBytes > 0) return void (e._closeRequested = !0); var r = e._pendingPullIntos[0]; if (x(t) === !0 && e._pendingPullIntos.length > 0 && r.bytesFilled > 0) { var n = new TypeError("Insufficient bytes to fill elements in the given buffer"); throw ve(e, n), n } C(t) } function me(e, t) { var r = e._controlledReadableStream; ut(e._closeRequested === !1), ut("readable" === r._state); var n = t.buffer, o = t.byteOffset, a = t.byteLength; if (Y(r) === !0) if (0 === F(r)) { var i = y(n); ie(e, i, o, a) } else { ut(0 === e._queue.length); var i = y(n), s = new Uint8Array(i, o, a); A(r, s, !1) } else if (x(r) === !0) { var i = y(n); ie(e, i, o, a), de(e) } else { ut(B(r) === !1, "stream must not be locked"); var i = y(n); ie(e, i, o, a) } } function ve(e, t) { var r = e._controlledReadableStream; ut("readable" === r._state), ne(e), e._queue = [], I(r, t) } function we(e) { return e._strategyHWM - e._totalQueuedBytes } function ge(e, t) { if (t = Number(t), u(t) === !1) throw new RangeError("bytesWritten must be a finite"); ut(e._pendingPullIntos.length > 0), he(e, t) } function Re(e, t) { ut(e._pendingPullIntos.length > 0); var r = e._pendingPullIntos[0]; if (r.byteOffset + r.bytesFilled !== t.byteOffset) throw new RangeError("The region specified by view does not match byobRequest"); if (r.byteLength !== t.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest"); r.buffer = t.buffer, he(e, t.byteLength) } function Se() { var e = function t(e) { return Ee(t._stream, e) }; return e } function Be(e) { return e._started === !1 ? void e._startedPromise.then(function () { Oe(e) })["catch"](_) : e._started === !0 ? Oe(e) : void 0 } function Pe(e) { vt("closing" === e._state, "stream must be in closing state while calling CloseWritableStream"); var t = c(e._underlyingSink, "close"); t.then(function () { "errored" !== e._state && (vt("closing" === e._state), e._closedPromise_resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._state = "closed") }, function (t) { return Ee(e, t) })["catch"](_) } function Ee(e, t) { if ("closed" !== e._state && "errored" !== e._state) { for (; e._queue.length > 0;) { var r = p(e._queue); "close" !== r && r._reject(t) } e._storedError = t, "waiting" === e._state && e._readyPromise_resolve(void 0), e._closedPromise_reject(t), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._state = "errored" } } function qe(e) { return o(e) ? !!Object.prototype.hasOwnProperty.call(e, "_underlyingSink") : !1 } function Te(e) { if ("closing" !== e._state) { vt("writable" === e._state || "waiting" === e._state, "stream must be in a writable or waiting state while calling SyncWritableStreamStateWithQueue"); var t = v(e._queue), r = t > e._strategyHWM; r === !0 && "writable" === e._state && (e._state = "waiting", e._readyPromise = new Promise(function (t, r) { e._readyPromise_resolve = t })), r === !1 && "waiting" === e._state && (e._state = "writable", e._readyPromise_resolve(void 0)) } } function Oe(e) { if (0 !== e._queue.length && e._writing !== !0) { var t = w(e._queue); return "close" === t ? (vt("closing" === e._state, "can't process final write record unless already closing"), p(e._queue), vt(0 === e._queue.length, "queue must be empty once the final write record is dequeued"), Pe(e)) : (e._writing = !0, void c(e._underlyingSink, "write", [t.chunk]).then(function () { "errored" !== e._state && (e._writing = !1, t._resolve(void 0), p(e._queue), Te(e), Oe(e)) }, function (t) { return Ee(e, t) })["catch"](_)) } } function je(e) { var t = e._controlledReadableByteStream; e._pullAgain = !1, e._pulling = !0; try { d(e._underlyingByteSource, "pull", []) } catch (r) { xe(e), "readable" === t._state && We(t, r) } e._pulling = !1 } function ke(e) { e._controlledReadableByteStream, St(e._pendingPullIntos.length > 0); var t = e._pendingPullIntos[0]; e._pullAgain = !1, e._pulling = !0; try { d(e._underlyingByteSource, "pullInto", [new Uint8Array(t.buffer, t.byteOffset + t.bytesFilled, t.byteLength - t.bytesFilled)]) } catch (r) { xe(e); var n = e._controlledReadableByteStream; "readable" === n._state && We(n, r) } e._pulling = !1 } function Ce(e) { e._pullAgain = !0, e._pulling || t.nextTick(Ie.bind(void 0, e)) } function Ie(e) { for (var t = e._controlledReadableByteStream; ;) { if (!e._pullAgain) return; if (e._closeRequested) return; if ("readable" !== t._state) return; var r = t._reader; if (void 0 === r) return; if ($e(r)) { if (0 === r._readRequests.length) return; je(e) } else { if (St(He(r), "reader must be ReadableByteStreamByobReader"), 0 === r._readIntoRequests.length) return; ke(e) } } } function ze(e, t) { if ("closed" === e._state) return Promise.resolve(void 0); if ("errored" === e._state) return Promise.reject(e._storedError); Le(e); var r = Ae(e._controller, t); return r.then(function () { }) } function Ae(e, t) { return e._pendingPullIntos.length > 0 && (e._pendingPullIntos[0].bytesFilled = 0), e._queue = [], e._totalQueuedBytes = 0, c(e._underlyingByteSource, "cancel", [t]) } function Le(e) { St(Ue(e), "stream must be ReadableByteStream"), St("readable" === e._state, "state must be readable"), e._state = "closed"; var t = e._reader; if (void 0 !== t) { if ($e(t)) { var r = !0, n = !1, o = void 0; try { for (var a, i = t._readRequests[Symbol.iterator]() ; !(r = (a = i.next()).done) ; r = !0) { var s = a.value; s.resolve(l(void 0, !0)) } } catch (u) { n = !0, o = u } finally { try { !r && i["return"] && i["return"]() } finally { if (n) throw o } } t._readRequests = [], De(t) } else St(He(t), "reader must be ReadableByteStreamByobReader"), 0 === t._readIntoRequests.length && De(t); Fe(t) } } function Fe(e) { e._state = "closed", e._closedPromise_resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0 } function xe(e) { e._pendingPullIntos = [], e._queue = [] } function Ye(e) { return e } function De(e) { St(void 0 !== e._ownerReadableByteStream._reader), St(void 0 !== e._ownerReadableByteStream), e._ownerReadableByteStream._reader = void 0, e._ownerReadableByteStream = void 0 } function Ne(e, t, r, n) { e._queue.push({ buffer: t, byteOffset: r, byteLength: n }), e._totalQueuedBytes += n } function We(e, t) { St(Ue(e), "stream must be ReadableByteStream"), St("readable" === e._state, "state must be readable"), e._state = "errored", e._storedError = t; var r = e._reader; if (void 0 !== r) { if ($e(r)) { var n = !0, o = !1, a = void 0; try { for (var i, s = r._readRequests[Symbol.iterator]() ; !(n = (i = s.next()).done) ; n = !0) { var l = i.value; l.reject(t) } } catch (u) { o = !0, a = u } finally { try { !n && s["return"] && s["return"]() } finally { if (o) throw a } } r._readRequests = [] } else { St(He(r), "reader must be ReadableByteStreamByobReader"); var d = !0, c = !1, f = void 0; try { for (var y, h = r._readIntoRequests[Symbol.iterator]() ; !(d = (y = h.next()).done) ; d = !0) { var l = y.value; l.reject(t) } } catch (u) { c = !0, f = u } finally { try { !d && h["return"] && h["return"]() } finally { if (c) throw f } } r._readIntoRequests = [] } De(r), r._state = "errored", r._storedError = t, r._closedPromise_reject(t), r._closedPromise_resolve = void 0, r._closedPromise_reject = void 0 } } function Me(e, t) { var r = t.elementSize, n = t.bytesFilled - t.bytesFilled % r, o = Math.min(e._totalQueuedBytes, t.byteLength - t.bytesFilled), a = t.bytesFilled + o, i = a - a % r, s = o, l = !1; i > n && (s = i - t.bytesFilled, l = !0); for (var u = e._queue; s > 0;) { var d = u[0], c = Math.min(s, d.byteLength), f = t.byteOffset + t.bytesFilled; new Uint8Array(t.buffer).set(new Uint8Array(d.buffer, d.byteOffset, c), f), d.byteLength === c ? u.shift() : (d.byteOffset += c, d.byteLength -= c), e._totalQueuedBytes -= c, t.bytesFilled += c, s -= c } return l || (St(0 === e._totalQueuedBytes, "queue must be empty"), St(t.bytesFilled > 0), St(t.bytesFilled < t.elementSize)), l } function Qe(e, t) {
                    e._state = t._state, "readable" === t._state ? (t._reader = e, e._ownerReadableByteStream = t, e._storedError = void 0,
                    e._closedPromise = new Promise(function (t, r) { e._closedPromise_resolve = t, e._closedPromise_reject = r })) : (e._ownerReadableByteStream = void 0, "closed" === t._state ? (e._storedError = void 0, e._closedPromise = Promise.resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0) : (St("errored" === t._state, "state must be errored"), e._storedError = t._storedError, e._closedPromise = Promise.reject(t._storedError), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0))
                } function Ue(e) { return o(e) ? !!Object.prototype.hasOwnProperty.call(e, "_controller") : !1 } function He(e) { return o(e) ? !!Object.prototype.hasOwnProperty.call(e, "_readIntoRequests") : !1 } function Je(e) { return o(e) ? !!Object.prototype.hasOwnProperty.call(e, "_controlledReadableByteStream") : !1 } function Ve(e) { return St(Ue(e), "IsReadableByteStreamLocked should only be used on known readable byte streams"), void 0 !== e._reader } function $e(e) { return o(e) ? !!Object.prototype.hasOwnProperty.call(e, "_readRequests") : !1 } function Ge(e) { var t = e._controller, r = e._reader; if (!(r._readRequests.length > 1)) { if (St(1 === r._readRequests.length), t._totalQueuedBytes > 0) { var n = t._queue.shift(); t._totalQueuedBytes -= n.byteLength; var o = new Uint8Array(n.buffer, n.byteOffset, n.byteLength); return tt(r, o), void (0 === t._totalQueuedBytes && t._closeRequested && Le(e)) } if (t._pulling) return void (t._pullAgain = !0); je(t), Ie(t) } } function Ze(e, t, r, n, o) { var a = e._controller, i = { buffer: t, byteOffset: r, byteLength: n, bytesFilled: 0, elementSize: o }; if (a._pendingPullIntos.length > 0) return i.buffer = Ye(i.buffer), void a._pendingPullIntos.push(i); if (a._totalQueuedBytes > 0) { var s = Me(a, i); if (s) return et(e._reader, i.buffer, i.bytesFilled), void (0 === a._totalQueuedBytes && a._closeRequested && Le(e)); if (a._closeRequested) return xe(a), void We(e, new TypeError("Insufficient bytes to fill elements in the given buffer")) } return i.buffer = Ye(i.buffer), a._pendingPullIntos.push(i), a._pulling ? void (a._pullAgain = !0) : (ke(a), void Ie(a)) } function Ke(e, t, r) { var n = e._pendingPullIntos[0]; for (void 0 !== r && (n.buffer = r), n.buffer = Ye(n.buffer), St(0 === n.bytesFilled, "bytesFilled must be 0") ; t._readIntoRequests.length > 0;) { var o = e._pendingPullIntos.shift(); et(t, o.buffer) } De(t) } function Xe(e, t, r, n) { var o = e._pendingPullIntos[0]; if (o.bytesFilled + r > o.byteLength) throw new RangeError("bytesWritten out of range"); if (void 0 !== n && (o.buffer = n), o.bytesFilled += r, o.bytesFilled < o.elementSize) return void Ce(e); e._pendingPullIntos.shift(); var a = o.bytesFilled % o.elementSize; if (a > 0) { var i = o.byteOffset + o.bytesFilled, s = o.buffer.slice(i - a, i); Ne(e, s, 0, s.byteLength) } et(t, Ye(o.buffer), o.bytesFilled - a), rt(e, t) } function et(e, t, r) { St(e._readIntoRequests.length > 0, "readIntoRequest must not be empty when calling RespondToReadIntoRequest"), St("errored" !== e._state, "state must not be errored"); var n = e._readIntoRequests.shift(), o = n.ctor, a = n.byteOffset; if ("closed" === e._state) { St(void 0 === r); var i = new o(t, a, 0); return void n.resolve(l(i, !0)) } St(r <= n.byteLength), St(r % n.elementSize === 0); var s = new o(t, a, r / n.elementSize); n.resolve(l(s, !1)) } function tt(e, t) { var r = e._readRequests.shift(); r.resolve(l(t, !1)) } function rt(e, t) { for (St(!e._closeRequested) ; e._pendingPullIntos.length > 0;) { if (0 === e._totalQueuedBytes) return void Ce(e); var r = e._pendingPullIntos[0], n = Me(e, r); n && (e._pendingPullIntos.shift(), et(t, r.buffer, r.bytesFilled)) } } Object.defineProperty(r, "__esModule", { value: !0 }); var nt = function () { function e(e, t) { var r = [], n = !0, o = !1, a = void 0; try { for (var i, s = e[Symbol.iterator]() ; !(n = (i = s.next()).done) && (r.push(i.value), !t || r.length !== t) ; n = !0); } catch (l) { o = !0, a = l } finally { try { !n && s["return"] && s["return"]() } finally { if (o) throw a } } return r } return function (t, r) { if (Array.isArray(t)) return t; if (Symbol.iterator in Object(t)) return e(t, r); throw new TypeError("Invalid attempt to destructure non-iterable instance") } }(), ot = function () { function e(e, t) { for (var r = 0; r < t.length; r++) { var n = t[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } return function (t, r, n) { return r && e(t.prototype, r), n && e(t, n), t } }(), at = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol ? "symbol" : typeof e }, it = e("assert"), st = e("assert"), lt = e("assert"), ut = e("assert"), dt = Symbol(), ct = Symbol(), ft = function () { function e() { var t = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0], r = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], o = r.size, a = r.highWaterMark; n(this, e), this._state = "readable", this._reader = void 0, this._storedError = void 0, this._disturbed = !1, this._readableStreamController = void 0; var i = t.byob; i === !0 ? (void 0 === a && (a = 0), this._readableStreamController = new pt(this, t, a)) : (void 0 === a && (a = 1), this._readableStreamController = new bt(this, t, o, a)) } return ot(e, [{ key: "cancel", value: function (e) { return S(this) === !1 ? Promise.reject(new TypeError("ReadableStream.prototype.cancel can only be used on a ReadableStream")) : B(this) === !0 ? Promise.reject(new TypeError("Cannot cancel a stream that already has a reader")) : k(this, e) } }, { key: "getBYOBReader", value: function () { if (S(this) === !1) throw new TypeError("ReadableStream.prototype.getBYOBReader can only be used on a ReadableStream constructed with a byte source"); if (ee(this._readableStreamController) === !1) throw new TypeError("Cannot get a ReadableStreamBYOBReader for a stream not constructed with a byte source"); return g(this) } }, { key: "getReader", value: function () { if (S(this) === !1) throw new TypeError("ReadableStream.prototype.getReader can only be used on a ReadableStream"); return R(this) } }, { key: "pipeThrough", value: function (e, t) { var r = e.writable, n = e.readable; return this.pipeTo(r, t), n } }, { key: "pipeTo", value: function (e) { function t() { c = d.read(), Promise.all([c, e.ready]).then(function (r) { var o = nt(r, 1), a = o[0], i = a.value, s = a.done; Boolean(s) === !0 ? n() : "writable" === e.state && (f = e.write(i), t()) })["catch"](_) } function r(e) { l === !1 ? (d.cancel(e), d.releaseLock(), b(e)) : c.then(function () { d.releaseLock(), b(e) }) } function n() { d.releaseLock(); var t = e.state; i !== !1 || "waiting" !== t && "writable" !== t ? void 0 !== f ? f.then(h, b) : h() : (y = !0, e.close().then(h, b)) } function o(t) { d.releaseLock(), s === !1 && e.abort(t), b(t) } var a = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], i = a.preventClose, s = a.preventAbort, l = a.preventCancel; i = Boolean(i), s = Boolean(s), l = Boolean(l); var u = this, d = void 0, c = void 0, f = void 0, y = !1, h = void 0, b = void 0; return new Promise(function (n, a) { h = n, b = a, d = u.getReader(), d.closed["catch"](o), e.closed.then(function () { y || r(new TypeError("destination is closing or closed and cannot be piped to anymore")) }, r), t() }) } }, { key: "tee", value: function () { if (S(this) === !1) throw new TypeError("ReadableStream.prototype.tee can only be used on a ReadableStream"); var e = P(this, !1); return i(e) } }, { key: "locked", get: function () { if (S(this) === !1) throw new TypeError("ReadableStream.prototype.locked can only be used on a ReadableStream"); return B(this) } }]), e }(), yt = function () { function e(t) { if (n(this, e), S(t) === !1) throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance"); if (B(t) === !0) throw new TypeError("This stream has already been locked for exclusive reading by another reader"); W(this, t), this._readRequests = [] } return ot(e, [{ key: "cancel", value: function (e) { return N(this) === !1 ? Promise.reject(new TypeError("ReadableStreamDefaultReader.prototype.cancel can only be used on a ReadableStreamDefaultReader")) : void 0 === this._ownerReadableStream ? Promise.reject(new TypeError("Cannot cancel a stream using a released reader")) : M(this, e) } }, { key: "read", value: function () { return N(this) === !1 ? Promise.reject(new TypeError("ReadableStreamDefaultReader.prototype.read can only be used on a ReadableStreamDefaultReader")) : void 0 === this._ownerReadableStream ? Promise.reject(new TypeError("Cannot read from a released reader")) : H(this) } }, { key: "releaseLock", value: function () { if (N(this) === !1) throw new TypeError("ReadableStreamDefaultReader.prototype.releaseLock can only be used on a ReadableStreamDefaultReader"); if (void 0 !== this._ownerReadableStream) { if (this._readRequests.length > 0) throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled"); Q(this) } } }, { key: "closed", get: function () { return N(this) === !1 ? Promise.reject(new TypeError("ReadableStreamDefaultReader.prototype.closed can only be used on a ReadableStreamDefaultReader")) : this._closedPromise } }]), e }(), ht = function () { function e(t) { if (n(this, e), !S(t)) throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source"); if (B(t)) throw new TypeError("This stream has already been locked for exclusive reading by another reader"); W(this, t), this._readIntoRequests = [] } return ot(e, [{ key: "cancel", value: function (e) { return D(this) ? void 0 === this._ownerReadableStream ? Promise.reject(new TypeError("Cannot cancel a stream using a released reader")) : M(this, e) : Promise.reject(new TypeError("ReadableStreamBYOBReader.prototype.cancel can only be used on a ReadableStreamBYOBReader")) } }, { key: "read", value: function (e) { return D(this) ? void 0 === this._ownerReadableStream ? Promise.reject(new TypeError("Cannot read from a released reader")) : ArrayBuffer.isView(e) ? 0 === e.byteLength ? Promise.reject(new TypeError("view must have non-zero byteLength")) : U(this, e) : Promise.reject(new TypeError("view must be an array buffer view")) : Promise.reject(new TypeError("ReadableStreamBYOBReader.prototype.read can only be used on a ReadableStreamBYOBReader")) } }, { key: "releaseLock", value: function () { if (!D(this)) throw new TypeError("ReadableStreamBYOBReader.prototype.releaseLock can only be used on a ReadableStreamBYOBReader"); if (void 0 !== this._ownerReadableStream) { if (this._readIntoRequests.length > 0) throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled"); Q(this) } } }, { key: "closed", get: function () { return D(this) ? this._closedPromise : Promise.reject(new TypeError("ReadableStreamBYOBReader.prototype.closed can only be used on a ReadableStreamBYOBReader")) } }]), e }(), bt = function () { function e(t, r, o, a) { if (n(this, e), S(t) === !1) throw new TypeError("ReadableStreamDefaultController can only be constructed with a ReadableStream instance"); if (void 0 !== t._readableStreamController) throw new TypeError("ReadableStreamDefaultController instances can only be created by the ReadableStream constructor"); this._controlledReadableStream = t, this._underlyingSource = r, this._queue = [], this._started = !1, this._closeRequested = !1, this._pullAgain = !1, this._pulling = !1; var i = b(o, a); this._strategySize = i.size, this._strategyHWM = i.highWaterMark; var s = this, l = d(r, "start", [this]); Promise.resolve(l).then(function () { s._started = !0, V(s) }, function (e) { "readable" === t._state && K(s, e) })["catch"](_) } return ot(e, [{ key: "close", value: function () { if (J(this) === !1) throw new TypeError("ReadableStreamDefaultController.prototype.close can only be used on a ReadableStreamDefaultController"); if (this._closeRequested === !0) throw new TypeError("The stream has already been closed; do not close it again!"); var e = this._controlledReadableStream._state; if ("readable" !== e) throw new TypeError("The stream (in " + e + " state) is not in the readable state and cannot be closed"); G(this) } }, { key: "enqueue", value: function (e) { if (J(this) === !1) throw new TypeError("ReadableStreamDefaultController.prototype.enqueue can only be used on a ReadableStreamDefaultController"); if (this._closeRequested === !0) throw new TypeError("stream is closed or draining"); var t = this._controlledReadableStream._state; if ("readable" !== t) throw new TypeError("The stream (in " + t + " state) is not in the readable state and cannot be enqueued to"); return Z(this, e) } }, { key: "error", value: function (e) { if (J(this) === !1) throw new TypeError("ReadableStreamDefaultController.prototype.error can only be used on a ReadableStreamDefaultController"); var t = this._controlledReadableStream; if ("readable" !== t._state) throw new TypeError("The stream is " + t._state + " and so cannot be errored"); K(this, e) } }, { key: dt, value: function (e) { return this._queue = [], c(this._underlyingSource, "cancel", [e]) } }, { key: ct, value: function () { var e = this._controlledReadableStream; if (this._queue.length > 0) { var t = p(this._queue); return this._closeRequested === !0 && 0 === this._queue.length ? C(e) : V(this), Promise.resolve(l(t, !1)) } var r = j(e); return V(this), r } }, { key: "desiredSize", get: function () { if (J(this) === !1) throw new TypeError("ReadableStreamDefaultController.prototype.desiredSize can only be used on a ReadableStreamDefaultController"); return X(this) } }]), e }(), _t = function () { function e(t, r) { n(this, e), this._associatedReadableStreamBYOBController = t, this._view = new Uint8Array(r.buffer, r.byteOffset + r.bytesFilled, r.byteLength - r.bytesFilled) } return ot(e, [{ key: "respond", value: function (e) { if (te(this) === !1) throw new TypeError("ReadableStreamBYOBController.prototype.respond can only be used on a ReadableStreamBYOBController"); if (void 0 === this._associatedReadableStreamBYOBController) throw new TypeError("This BYOB request has been invalidated"); ge(this._associatedReadableStreamBYOBController, e) } }, { key: "respondWithNewView", value: function (e) { if (te(this) === !1) throw new TypeError("ReadableStreamBYOBController.prototype.respond can only be used on a ReadableStreamBYOBController"); if (void 0 === this._associatedReadableStreamBYOBController) throw new TypeError("This BYOB request has been invalidated"); if (!ArrayBuffer.isView(e)) throw new TypeError("You can only respond with array buffer views"); Re(this._associatedReadableStreamBYOBController, e) } }, { key: "_invalidate", value: function () { this._associatedReadableStreamBYOBController = void 0, this._view = void 0 } }, { key: "view", get: function () { return this._view } }]), e }(), pt = function () { function e(t, r, o) { if (n(this, e), S(t) === !1) throw new TypeError("ReadableStreamBYOBController can only be constructed with a ReadableStream instance given a byte source"); if (void 0 !== t._readableStreamController) throw new TypeError("ReadableStreamBYOBController instances can only be created by the ReadableStream constructor given a byte source"); this._controlledReadableStream = t, this._underlyingByteSource = r, this._pullAgain = !1, this._pulling = !1, ne(this), this._queue = [], this._totalQueuedBytes = 0, this._closeRequested = !1, this._started = !1, this._strategyHWM = h(o); var a = r.autoAllocateChunkSize; if (void 0 !== a && (Number.isInteger(a) === !1 || 0 > a)) throw new RangeError("autoAllocateChunkSize must be a non negative integer"); this._autoAllocateChunkSize = a, this._pendingPullIntos = []; var i = this, s = d(r, "start", [this]); Promise.resolve(s).then(function () { i._started = !0, ut(i._pulling === !1), ut(i._pullAgain === !1), re(i) }, function (e) { "readable" === t._state && ve(i, e) })["catch"](_) } return ot(e, [{ key: "close", value: function () { if (ee(this) === !1) throw new TypeError("ReadableStreamBYOBController.prototype.close can only be used on a ReadableStreamBYOBController"); if (this._closeRequested === !0) throw new TypeError("The stream has already been closed; do not close it again!"); var e = this._controlledReadableStream._state; if ("readable" !== e) throw new TypeError("The stream (in " + e + " state) is not in the readable state and cannot be closed"); pe(this) } }, { key: "enqueue", value: function (e) { if (ee(this) === !1) throw new TypeError("ReadableStreamBYOBController.prototype.enqueue can only be used on a ReadableStreamBYOBController"); if (this._closeRequested === !0) throw new TypeError("stream is closed or draining"); var t = this._controlledReadableStream._state; if ("readable" !== t) throw new TypeError("The stream (in " + t + " state) is not in the readable state and cannot be enqueued to"); if (!ArrayBuffer.isView(e)) throw new TypeError("You can only enqueue array buffer views when using a ReadableStreamBYOBController"); me(this, e) } }, { key: "error", value: function (e) { if (ee(this) === !1) throw new TypeError("ReadableStreamBYOBController.prototype.error can only be used on a ReadableStreamBYOBController"); var t = this._controlledReadableStream; if ("readable" !== t._state) throw new TypeError("The stream is " + t._state + " and so cannot be errored"); ve(this, e) } }, { key: dt, value: function (e) { if (this._pendingPullIntos.length > 0) { var t = this._pendingPullIntos[0]; t.bytesFilled = 0 } return this._queue = [], this._totalQueuedBytes = 0, c(this._underlyingByteSource, "cancel", [e]) } }, { key: ct, value: function () { var e = this._controlledReadableStream; if (0 === F(e)) { if (this._totalQueuedBytes > 0) { var t = this._queue.shift(); this._totalQueuedBytes -= t.byteLength, ue(this); var r = new Uint8Array(t.buffer, t.byteOffset, t.byteLength); return Promise.resolve(l(r, !1)) } var n = this._autoAllocateChunkSize; if (void 0 !== n) { var o = new ArrayBuffer(n), a = { buffer: o, byteOffset: 0, byteLength: n, bytesFilled: 0, elementSize: 1, ctor: Uint8Array, readerType: "default" }; this._pendingPullIntos.push(a) } } else ut(void 0 === this._autoAllocateChunkSize); var i = j(e); return re(this), i } }, { key: "byobRequest", get: function () { if (ee(this) === !1) throw new TypeError("ReadableStreamBYOBController.prototype.byobRequest can only be used on a ReadableStreamBYOBController"); if (void 0 === this._byobRequest && this._pendingPullIntos.length > 0) { var e = this._pendingPullIntos[0]; this._byobRequest = new _t(this, e) } return this._byobRequest } }, { key: "desiredSize", get: function () { if (ee(this) === !1) throw new TypeError("ReadableStreamBYOBController.prototype.desiredSize can only be used on a ReadableStreamBYOBController"); return we(this) } }]), e }(), mt = function () { function e(t) { var r = t.highWaterMark; n(this, e), a(this, "highWaterMark", r) } return ot(e, [{ key: "size", value: function (e) { return 1 } }]), e }(), vt = e("assert"), wt = function () { function e() { var t = this, r = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0], o = arguments.length <= 1 || void 0 === arguments[1] ? {} : arguments[1], a = o.size, i = o.highWaterMark, s = void 0 === i ? 0 : i; n(this, e), this._underlyingSink = r, this._closedPromise = new Promise(function (e, r) { t._closedPromise_resolve = e, t._closedPromise_reject = r }), this._readyPromise = Promise.resolve(void 0), this._readyPromise_resolve = null, this._queue = [], this._state = "writable", this._started = !1, this._writing = !1; var l = b(a, s); this._strategySize = l.size, this._strategyHWM = l.highWaterMark, Te(this); var u = Se(); u._stream = this; var c = d(r, "start", [u]); this._startedPromise = Promise.resolve(c), this._startedPromise.then(function () { t._started = !0, t._startedPromise = void 0 }), this._startedPromise["catch"](function (e) { return Ee(t, e) })["catch"](_) } return ot(e, [{ key: "abort", value: function (e) { if (!qe(this)) return Promise.reject(new TypeError("WritableStream.prototype.abort can only be used on a WritableStream")); if ("closed" === this._state) return Promise.resolve(void 0); if ("errored" === this._state) return Promise.reject(this._storedError); Ee(this, e); var t = f(this._underlyingSink, "abort", [e], "close", []); return t.then(function () { }) } }, { key: "close", value: function () { return qe(this) ? "closing" === this._state ? Promise.reject(new TypeError("cannot close an already-closing stream")) : "closed" === this._state ? Promise.reject(new TypeError("cannot close an already-closed stream")) : "errored" === this._state ? Promise.reject(this._storedError) : ("waiting" === this._state && this._readyPromise_resolve(void 0), this._state = "closing", m(this._queue, "close", 0), Be(this), this._closedPromise) : Promise.reject(new TypeError("WritableStream.prototype.close can only be used on a WritableStream")) } }, { key: "write", value: function (e) { if (!qe(this)) return Promise.reject(new TypeError("WritableStream.prototype.write can only be used on a WritableStream")); if ("closing" === this._state) return Promise.reject(new TypeError("cannot write while stream is closing")); if ("closed" === this._state) return Promise.reject(new TypeError("cannot write after stream is closed")); if ("errored" === this._state) return Promise.reject(this._storedError); vt("waiting" === this._state || "writable" === this._state); var t = 1; if (void 0 !== this._strategySize) try { t = this._strategySize(e) } catch (r) { return Ee(this, r), Promise.reject(r) } var n = void 0, o = void 0, a = new Promise(function (e, t) { n = e, o = t }), i = { promise: a, chunk: e, _resolve: n, _reject: o }; try { m(this._queue, i, t) } catch (s) { return Ee(this, s), Promise.reject(s) } return Te(this), Be(this), a } }, { key: "closed", get: function () { return qe(this) ? this._closedPromise : Promise.reject(new TypeError("WritableStream.prototype.closed can only be used on a WritableStream")) } }, { key: "state", get: function () { if (!qe(this)) throw new TypeError("WritableStream.prototype.state can only be used on a WritableStream"); return this._state } }, { key: "ready", get: function () { return qe(this) ? this._readyPromise : Promise.reject(new TypeError("WritableStream.prototype.ready can only be used on a WritableStream")) } }]), e }(), gt = function () { function e(t) { var r = t.highWaterMark; n(this, e), a(this, "highWaterMark", r) } return ot(e, [{ key: "size", value: function (e) { return e.byteLength } }]), e }(), Rt = function Ot(e) { function t() { if (s === !1) { s = !0; try { e.transform(o, u, r), o = void 0, l = !1 } catch (t) { s = !1, i(t), c(t) } } } function r() { s = !1, a() } if (n(this, Ot), void 0 === e.flush && (e.flush = function (e, t) { return t() }), "function" != typeof e.transform) throw new TypeError("transform must be a function"); var o = void 0, a = void 0, i = void 0, s = !1, l = !1; this.writable = new wt({ start: function (e) { i = e }, write: function (e) { o = e, l = !0; var r = new Promise(function (e) { return a = e }); return t(), r }, close: function () { try { e.flush(u, d) } catch (t) { i(t), c(t) } } }, e.writableStrategy); var u = void 0, d = void 0, c = void 0; this.readable = new ft({ start: function (e) { u = e.enqueue.bind(e), d = e.close.bind(e), c = e.error.bind(e) }, pull: function () { l === !0 && t() } }, e.readableStrategy) }, St = e("assert"), Bt = function () { function e() { var t = arguments.length <= 0 || void 0 === arguments[0] ? {} : arguments[0]; n(this, e), this._state = "readable", this._reader = void 0, this._storedError = void 0, this._controller = void 0, this._controller = new Pt(this, t) } return ot(e, [{ key: "cancel", value: function (e) { return Ue(this) === !1 ? Promise.reject(new TypeError("ReadableByteStream.prototype.cancel can only be used on a ReadableByteStream")) : Ve(this) === !0 ? Promise.reject(new TypeError("Cannot cancel a stream that already has a reader")) : ze(this, e) } }, { key: "getByobReader", value: function () { if (Ue(this) === !1) throw new TypeError("ReadableByteStream.prototype.getByobReader can only be used on a ReadableByteStream"); return new qt(this) } }, { key: "getReader", value: function () { if (Ue(this) === !1) throw new TypeError("ReadableByteStream.prototype.getReader can only be used on a ReadableByteStream"); return new Et(this) } }]), e }(), Pt = function () { function e(t, r) { if (n(this, e), Ue(t) === !1) throw new TypeError("ReadableByteStreamController can only be constructed with a ReadableByteStream instance"); if (void 0 !== t._controller) throw new TypeError("ReadableByteStreamController instances can only be created by the ReadableByteStream constructor"); this._controlledReadableByteStream = t, this._underlyingByteSource = r, this._pullAgain = !1, this._pulling = !1, this._pendingPullIntos = [], this._queue = [], this._totalQueuedBytes = 0, this._closeRequested = !1, d(r, "start", [this]) } return ot(e, [{ key: "close", value: function () { if (!Je(this)) throw new TypeError("ReadableByteStreamController.prototype.close can only be used on a ReadableByteStreamController"); var e = this._controlledReadableByteStream; if (this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!"); if ("readable" !== e._state) throw new TypeError("The stream is not in the readable state and cannot be closed"); if (this._totalQueuedBytes > 0) return void (this._closeRequested = !0); var t = e._reader; if (He(t) && this._pendingPullIntos.length > 0) { var r = this._pendingPullIntos[0]; if (r.bytesFilled > 0) { xe(this); var n = new TypeError("Insufficient bytes to fill elements in the given buffer"); throw We(e, n), n } } Le(e) } }, { key: "enqueue", value: function (e) { if (!Je(this)) throw new TypeError("ReadableByteStreamController.prototype.enqueue can only be used on a ReadableByteStreamController"); var t = this._controlledReadableByteStream; if (this._closeRequested) throw new TypeError("stream is closed or draining"); if ("readable" !== t._state) throw new TypeError("The stream is not in the readable state and cannot be enqueued to"); var r = t._reader, n = e.buffer, o = e.byteOffset, a = e.byteLength; if (void 0 === r) Ne(this, Ye(n), o, a); else if ($e(r)) if (0 === r._readRequests.length) Ne(this, Ye(n), o, a); else { St(0 === this._queue.length); var i = new Uint8Array(Ye(n), o, a); tt(r, i), r._readRequests.length > 0 && Ce(this) } else St(He(r), "reader must be ReadableByteStreamByobReader"), Ne(this, Ye(n), o, a), rt(this, r) } }, { key: "error", value: function (e) { if (!Je(this)) throw new TypeError("ReadableByteStreamController.prototype.error can only be used on a ReadableByteStreamController"); var t = this._controlledReadableByteStream; if ("readable" !== t._state) throw new TypeError("The stream is " + t._state + " and so cannot be errored"); xe(this), We(t, e) } }, { key: "respond", value: function (e, t) { if (!Je(this)) throw new TypeError("ReadableByteStreamController.prototype.respond can only be used on a ReadableByteStreamController"); var r = this._controlledReadableByteStream; if (0 === this._pendingPullIntos.length) throw new TypeError("No pending BYOB read"); St(Ve(r), "stream must be locked"); var n = r._reader; if (St(He(n), "reader must be ReadableByteStreamByobReader"), "closed" === r._state) { if (0 !== e) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream"); Ke(this, n, t) } else St("readable" === r._state), Xe(this, n, e, t) } }]), e }(), Et = function () { function e(t) { if (n(this, e), !Ue(t)) throw new TypeError("ReadableByteStreamReader can only be constructed with a ReadableByteStream instance"); if (Ve(t)) throw new TypeError("This stream has already been locked for exclusive reading by another reader"); Qe(this, t), this._readRequests = [] } return ot(e, [{ key: "cancel", value: function (e) { return $e(this) ? "closed" === this._state ? Promise.resolve(void 0) : "errored" === this._state ? Promise.reject(this._storedError) : (St(void 0 !== this._ownerReadableByteStream, "This reader must be attached to a stream"), ze(this._ownerReadableByteStream, e)) : Promise.reject(new TypeError("ReadableByteStreamReader.prototype.cancel can only be used on a ReadableByteStreamReader")) } }, { key: "read", value: function () { var e = this; if (!$e(this)) return Promise.reject(new TypeError("ReadableByteStreamReader.prototype.read can only be used on a ReadableByteStreamReader")); if ("closed" === this._state) return Promise.resolve(l(void 0, !0)); if ("errored" === this._state) return Promise.reject(this._storedError); St(void 0 !== this._ownerReadableByteStream, "This reader must be attached to a stream"), St("readable" === this._ownerReadableByteStream._state, "The owner stream must be in readable state"); var t = new Promise(function (t, r) { e._readRequests.push({ resolve: t, reject: r }) }); return Ge(this._ownerReadableByteStream), t } }, { key: "releaseLock", value: function () { if (!$e(this)) throw new TypeError("ReadableByteStreamReader.prototype.releaseLock can only be used on a ReadableByteStreamReader"); if (void 0 !== this._ownerReadableByteStream) { if (this._readRequests.length > 0) throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled"); St("readable" === this._ownerReadableByteStream._state), De(this), Fe(this) } } }, { key: "closed", get: function () { return $e(this) ? this._closedPromise : Promise.reject(new TypeError("ReadableByteStreamReader.prototype.closed can only be used on a ReadableByteStreamReader")) } }]), e }(), qt = function () { function e(t) { if (n(this, e), !Ue(t)) throw new TypeError("ReadableByteStreamByobReader can only be constructed with a ReadableByteStream instance"); if (Ve(t)) throw new TypeError("This stream has already been locked for exclusive reading by another reader"); Qe(this, t), this._readIntoRequests = [] } return ot(e, [{ key: "cancel", value: function (e) { return He(this) ? "closed" === this._state ? Promise.resolve(void 0) : "errored" === this._state ? Promise.reject(this._storedError) : (St(void 0 !== this._ownerReadableByteStream, "This stream must be attached to a stream"), ze(this._ownerReadableByteStream, e)) : Promise.reject(new TypeError("ReadableByteStreamByobReader.prototype.cancel can only be used on a ReadableByteStreamByobReader")) } }, { key: "read", value: function (e) { var t = this; if (!He(this)) return Promise.reject(new TypeError("ReadableByteStreamByobReader.prototype.read can only be used on a ReadableByteStreamByobReader")); if (void 0 === e || !ArrayBuffer.isView(e)) return Promise.reject(new TypeError("Valid view must be provided")); var r = e.constructor, n = 1; if (r === Int16Array || r === Uint16Array || r === Int32Array || r === Uint32Array || r === Float32Array || r === Float64Array || r === Int8Array || r === Uint8Array || r === Uint8ClampedArray) n = r.BYTES_PER_ELEMENT; else if (r !== DataView) return Promise.reject(new TypeError("view is of an unsupported type")); if (0 === e.byteLength) return Promise.reject(new TypeError("view must have non-zero byteLength")); if ("errored" === this._state) return St(void 0 === this._ownerReadableByteStream, "This reader must be detached"), Promise.reject(this._storedError); if ("closed" === this._state && void 0 === this._ownerReadableByteStream) return Promise.resolve(l(new r(e.buffer, e.byteOffset, 0), !0)); var o = new Promise(function (o, a) { var i = { resolve: o, reject: a, byteOffset: e.byteOffset, byteLength: e.byteLength, ctor: r, elementSize: n }; t._readIntoRequests.push(i) }); return Ze(this._ownerReadableByteStream, e.buffer, e.byteOffset, e.byteLength, n), o } }, { key: "releaseLock", value: function () { if (!He(this)) throw new TypeError("ReadableByteStreamByobReader.prototype.releaseLock can only be used on a ReadableByteStreamByobReader"); if (void 0 !== this._ownerReadableByteStream) { if (this._readIntoRequests.length > 0) throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled"); St("readable" === this._ownerReadableByteStream._state), De(this), Fe(this) } } }, { key: "closed", get: function () { return He(this) ? this._closedPromise : Promise.reject(new TypeError("ReadableByteStreamByobReader.prototype.closed can only be used on a ReadableByteStreamByobReader")) } }]), e }(), Tt = { ReadableByteStream: Bt, ReadableStream: ft, WritableStream: wt, ByteLengthQueuingStrategy: gt, CountQueuingStrategy: mt, TransformStream: Rt }; "undefined" != typeof window && Object.assign(window, Tt), r["default"] = Tt
            }).call(this, e("_process"))
        }, { _process: 3, assert: 1 }]
    }, {}, [6])(6)
});